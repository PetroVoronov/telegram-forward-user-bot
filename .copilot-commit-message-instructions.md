# Commit Message Guide (Concise)

Conventional Commits + release-please. Multi-entry (multiple headers in one commit) is MANDATORY whenever a commit affects more than one substantive component (class, module, folder, feature). One header per component.

## 1. Header

Format: `type(scope): summary`

Types: feat | fix | perf | refactor | docs | test | build | ci | chore | style | deps

Scope: EXACT component identifier (file/class/module/folder keyword): e.g. `scriptProperties`, `scriptCompletion`, `languageFiles`, `extension`, `lua`, `build`. Do NOT use umbrella scopes (e.g. `scripts`) or comma scopes. If multiple components change, add additional headers (multi-entry) instead of broadening scope.

Summary: imperative, <=72 chars, no period, describes intent + effect.

## 2. Body

Blank line after header. Optional. With two space indentation per line. One line per significant file or class:

```text
  src/path/file.ts: what changed (why/impact)
  Class Name: what changed (why)
```

User-facing first, internal later. Trivial style-only edits: separate `style:` commit or prefix line with `style:`.

### 2.1 Granular Change Points (MANDATORY DETAIL LEVEL)

Body lines MUST reference the most specific changed program element(s) when substantive (logic / API / behavior). Use one line per element category when clarity improves scanability. Prefer stable identifiers.

Allowed granular targets (in order of preference):

* File path (broad grouping)
* Class \<Name\>
* Class \<Name\>#methodName(params)
* function functionName(params)
* interface \<Name\> / type \<Name\>
* enum \<Name\> / enum \<Name\>.\<Member\>
* variable/const \<NAME\> (top-level exported) or prop \<Class\>.\<prop\>

Recommended notation tokens (prefix at start of description segment, optional but encouraged):

* `+` added
* `-` removed
* `~` modified (non-breaking)
* `!` breaking change (also still add BREAKING CHANGE footer if external)
* `≈` refactored equivalent behavior
* `Δ` performance-impacting modification

Format patterns:

```text
Class ScriptProperties#initialize(): +async init path (non-blocking startup)
function parseLanguageFile(path): ~stream parsing (reduce memory)
src/scripts/scriptCompletion.ts: Δ loop optimization (avoid quadratic filtering)
Class CompletionProvider#provideCompletionItems(): ! signature drop 'token' param (internal) (see below)
const MAX_KEYWORDS: -removed (unused)
prop ScriptProperties.cache: +added (memoize keyword lookups)
interface KeywordEntry: ~add optional 'category'
```

If multiple tiny related changes occur inside one class, aggregate under the class line and enumerate methods inline separated by semicolons:

```text
Class LanguageFiles: ~load(); +indexLanguages(); ~parseFile(): streaming SAX
```

Signature changes should specify old → new when not obvious:

```text
Class ScriptProperties#processKeywords(files[]): signature files[] -> sources[] (generalized input)
```

Variable lines only for additions/removals/renames of exported or widely used constants / config toggles. Skip local implementation detail variables.

Avoid vague descriptions; specify what changed AND the direct impact (latency, memory, correctness, API surface, safety, etc.).

When a line uses `!` include a concise migration note either in parentheses or in the BREAKING footer.

## 3. Footers

Use only as needed (with the same indentation rules as for the bodies):

* BREAKING CHANGE: impact + migration
* Closes #123 / Refs #456
* deps: bump \<pkg\> from \<old\> to \<new\>
* (Security) still use fix:; add CVE if any

## 4. Breaking Changes

Only for externally observable or API behavior changes. Each breaking entry (primary or secondary) needs its own `BREAKING CHANGE:` footer placed directly under that entry.

## 5. Multi-Entry Commits (Mandatory for Multi-Component Changes)

Required whenever the diff includes more than one substantive component. Each component gets its own header block. Prefer separate physical commits only if they can stand independently AND keep history bisectable; otherwise multi-entry.

Structure (repeat header/body/footers per component):

```text
<primary header>

  <primary body>
  <primary footers>

<secondary header>
  <secondary body (optional)>
  <secondary footers (optional)>

<tertiary header> ... etc
```

Rules:

1. Additional headers start at column 1 after a blank line.
2. Exactly one component per header (no umbrella or multi-component scopes).
3. Body lines under a header list ONLY that component's files/classes.
4. Footers apply only to the immediately preceding header block.
5. Breaking for multiple components? Duplicate appropriately tailored `BREAKING CHANGE:` footers under each affected header (avoid vague shared footer).
6. Nothing after the final entry's footers.
7. Do NOT fabricate extra headers for trivial style noise—exclude or separate into its own commit.

Example (three components changed):

```text
feat: add v4 UUID support

  Implements UUID v4 generation for scripts.

fix(utils): unicode encode no longer throws
  BREAKING CHANGE: encode() now returns fallback string instead of throwing.

feat(utils): add unicode-capable encode variant
```

### Indentation Rules (Multi-Entry Metadata)

When including metadata/footer lines (e.g. `PiperOrigin-RevId:`, `Source-Link:`, internal IDs) for secondary or tertiary headers you MAY indent them by two spaces for readability. Indentation is optional; consistency within a commit is preferred. The `BREAKING CHANGE:` footer line itself should NOT be indented (to ensure parsers pick it up cleanly).

Indented example with metadata:

```text
feat: adds v4 UUID to crypto

This adds support for v4 UUIDs to the library.

fix(utils): unicode no longer throws exception
  PiperOrigin-RevId: 345559154
  BREAKING CHANGE: encode method no longer throws.
  Source-Link: googleapis/googleapis@5e0dcb2

feat(utils): update encode to support unicode
  PiperOrigin-RevId: 345559182
  Source-Link: googleapis/googleapis@e5eef86
```

Parsing expectations:

* Each unindented `type(scope?): summary` line starts a new entry.
* Indented lines (2 leading spaces) immediately following a header or its body belong to that entry's body/footers.
* A blank line separates entries.
* `BREAKING CHANGE:` (indented or not) is associated with the closest preceding header without an intervening new header line.

## 6. Examples

Feature + perf:

```text
feat(languageFiles): async load with concurrency

  Class LanguageFiles#loadAll(): ~async refactor (prevent extension host blocking)
  function parseLanguageFile(path): +concurrency limit (8 workers)

feat(scriptProperties): async initialization

  Class ScriptProperties#initialize(): +async; -sync path (non-blocking startup)
  prop ScriptProperties.cache: +added memoization (reduces repeat parsing)

refactor(extension): await readiness of scriptProperties & languageFiles

  src/extension.ts: ~activation flow (providers registered after data ready)
```

Bug fix:

```text
fix(completion): suppress suggestions inside single-quoted attribute values

  function isInsideSingleQuotedString(text,pos): +added (central quote detection)
  Class CompletionProvider#provideCompletionItems(): ~early return when inside single-quoted value (reduces noise)
```

Breaking refactor:

```text
refactor(api): remove deprecated synchronous init path
  
  src/init/legacyInit.ts: -removed (obsolete)
  Class ExtensionActivator#activate(): ~drop legacyInit(); ~await ScriptProperties.initialize()
  BREAKING CHANGE: callers must await initialize() before provider use (sync path removed).
```

## 7. Checklist (Pre-Commit)

1. Every substantive component changed has its own header (no umbrella / multi scopes).
2. Each header: valid type + precise component scope + imperative summary (<=72 chars, no period).
3. Bodies: per-header; only files/classes of that component; concise what + why.
4. Breaking changes duplicated under each affected component's header (if applicable).
5. Footers (refs, deps) scoped to relevant header only.
6. No vague verbs (avoid solitary "update", "improve").
7. No build artifacts or timestamps.
8. Regex validation passes for every header.
9. Only substantive components get headers (don't add headers for trivial whitespace).

## 8. Validation Regex (Header)

```regex
^(feat|fix|perf|refactor|docs|test|build|ci|chore|style|deps)(\([a-z0-9_.,-]+\))?: [A-Z0-9].{0,71}$
```

Secondary headers in multi-entry commits must also match this pattern starting at column 1 after a blank line.

## 9. Multi-Entry Detection Heuristic

After the first block, treat any line matching the header regex (column 1, preceded by a blank line) as a new entry until EOF.

Adhere to these concise rules for consistent automated releases, readable history, and accurate changelogs.
